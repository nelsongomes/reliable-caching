# Key Generation

Key generation is almost as important as a cache content itself. Code provided here generate functions to abstract several issues around cache content, namely:

1. operation being cached
2. data classification (optional)
3. schema versioning (optional)
4. service (optional)
5. signing key ID (optional)
   <br/>

## Table of Contents

<!-- prettier-ignore-start -->

- [Simple Example](#simple-example)
- [Data classification example](#data-classification-example)
- [Schema versioning example](#schema-versioning-example)
- [Service example](#service-example)
- [Signed cache example](#signed-cache-example)
- [Complex example](#complex-example)

<!-- prettier-ignore-end -->

## Simple Example

KeyGenerator class provides a method to generate typed functions. In below example we are generating a function createCustomerKey that receives a user as a number and a companyName as a string to be used as part of cache key. The only argument mandatory is operation name. Generated function can then be called to generate cache keys for this operation.

```ts
const createCustomerKey = KeyGenerator.keyFactory<{
  // cache key types
  user: number;
  companyName: string;
}>({
  // keyFactory arguments
  operation: "getCustomer",
});

console.log(createCustomerKey({ companyName: "name", user: 123 }));
// getCustomer#v1:service=unknown:owner=public:companyName=name:user=123
```

## Data classification example

Sometimes it also makes sense to declare data ownership of data being cached to give more visibility on GDPR issues. Below example adds the information that data belongs to an user. Possible values are:

- OrganizationOwned - data is not public, organization owned
- PublicData - data is public, no owner
- SharedData - data is not public, but can be shared
- UserOwned - data is not public, user owned
- UserOrgOwned = data is not public, owned by an organization user

```ts
const createCustomerKey = KeyGenerator.keyFactory<{
  // cache key types
  user: number;
  companyName: string;
}>({
  // keyFactory arguments
  operation: "getCustomer",
  dataOwner: DataOwner.UserOwned,
});

console.log(createCustomerKey({ companyName: "name", user: 123 }));
// getCustomer#v1:service=unknown:owner=user:companyName=name:user=123
```

## Schema versioning example

Every time we change the schema of the cached data, we may trigger errors because old instances expect a different schema, new instances don't expect old schema already in cache and if this gets to a live environment only gets resolved by clearing cache. What this proposes is to add a version as part of cache key, this way, existent keys still work will old instances, new keys are used by new instances only.
So next time, you need to change the schema of the cached content, you just need to change schemaVersion for old cache to continue to work without conflicting with new cache content.

```ts
const createCustomerKey = KeyGenerator.keyFactory<{
  // cache key types
  user: number;
  companyName: string;
}>({
  // keyFactory arguments
  operation: "getCustomer",
  schemaVersion: 2, // change this if cache content schema has changed
});

console.log(createCustomerKey({ companyName: "name", user: 123 }));
// getCustomer#v2:service=unknown:owner=public:companyName=name:user=123
```

## Service example

To make sure cache keys don't collide between different services we can also declare the service that create the key. This way, different service caches don't collide even if cache functions get copy pasted.

```ts
const createCustomerKey = KeyGenerator.keyFactory<{
  // cache key types
  user: number;
  companyName: string;
}>({
  // keyFactory arguments
  operation: "getCustomer",
  schemaVersion: 2,
  service: "customerService",
});

console.log(createCustomerKey({ companyName: "name", user: 123 }));
// getCustomer#v2:service=customerService:owner=public:companyName=name:user=123
```

## Signed cache example

For critically important data, we may choose to sign it, to make sure it's not changed and that it was generated by our code. This way we can prevent cache poisining, which allows to do things like tampering with a product price to buy it cheaper.
But to use it, all signingKeyId's must be declared, old (still in cache) and new (in code), otherwise data will be rejected and cache will react as a miss, regenerating it.

```ts
SignManager.addKey("key1", "secret");

const signedCreateCustomerKey = KeyGenerator.keyFactory<{
  // cache key types
  user: number;
  companyName: string;
}>({
  // keyFactory arguments
  operation: "getCustomer",
  signingKeyId: "key1", // this key is used to signed cached content and to validate it
});

console.log(createCustomerKey({ companyName: "name", user: 123 }));
// !!!key1:getCustomer#v1:service=unknown:owner=public:companyName=name:user=123
```

## Complex example

This complex example generates a function that expects to receive a company and productId to generate a key for operation getCompanyProduct, current schema version is 2 and cached data belongs to an organization.

```ts
const createCustomerKey = KeyGenerator.keyFactory<{
  // cache key types
  company: number;
  productId: number;
}>({
  // keyFactory arguments
  operation: "getCompanyProduct",
  schemaVersion: 2,
  service: "products-api",
  dataOwner: DataOwner.OrganizationOwned,
});

console.log(createCustomerKey({ company: 1234, productId: 5678 }));
// getCompanyProduct#v2:service=products-api:owner=org:company=1234:productId=5678
```

### Visit the [GitHub Repo](https://github.com/nelsongomes/reliable-caching/) tutorials, documentation, and support

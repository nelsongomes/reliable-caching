# URL Signing

Purpose of URL signing is to prevent mainly cache poisoning. But it can also be used to prevent attacks generated by automated hacking tools.
Imagine your url is something like https://site.com/product/123, it is easily guessable that if you generate a loop from 1 to 1M and replace the number in URL you will hit the database at least trying to find a product that does not exist, and receive a '404 Not Found' status code.
And for this case, having validation in place and a cache won't protect you much, because the amount of products can be very large and it can make your database to stop responding for a long period of time, trying to find and cache products that don't exist.

So, how can we protect it? We can rate limit request count, but better than that and we can sign our URIs to prevent random guessing, this way we allow only our own generated URLs for products that exist.

For URL signatures we use RIPEMD-160 hash function because it produces a smaller hash, more suitable for Internet use, though still with 160bits.

## Table of Contents

<!-- prettier-ignore-start -->

- [Declaring your keys](#declaring-your-keys)
- [Signing URL data](#signing-url-data)
- [Verifying URL request](#verifying-url-request)

<!-- prettier-ignore-end -->

## Declaring your keys

SignManager expects all your private keys to be declared. If you rotate keys you should keep old key for some time for generated URLs to continue to work for some time. Otherwise all existent URL might stop working without notice.

```ts
// this is only done once per key
SignManager.addKey("myOlderKey", "myOldSecret");
SignManager.addKey("myPrivateKey", "mySecret");
```

## Signing URL data

This example signs content that goes into cache with a signature. This is a generic example that requires you to implement your store function.

```ts
// sign content
const signatureInfo = SignManager.signUrlParams(
  { product: 123 }, // you should put here all values that you need to protect
  "myPrivateKey"
);

// which will return something like next string that you should append to your URL
// rck=myPrivateKey&rks=c96f535c21f51(...)
// rck - reliable caching key
// rcs - reliable caching signature
```

## Verifying URL request

This example validates content retrieved from cache. This is a generic example that requires you to implement your store function.

```ts
// URL requested > https://site.com/product/123?rck=myPrivateKey&rks=c96f535c21f51(...)

const isSigned = SignManager.verifySignedUrlParams(
  {
    product: context.params.product,
  },
  context.query.rck, // key used to sign
  context.query.rcs // signature of protected content
);

if (!isSigned) {
  reply.code(400).type("text/html").send("Bad request");
  return;
}

// request is good
handleRequest(context);
```

### Visit the [GitHub Repo](https://github.com/nelsongomes/reliable-caching/) tutorials, documentation, and support
